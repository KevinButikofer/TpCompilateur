Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    COCHON_EGAL_PORC
    FERMEZ_VOS_ORDINATEUR
    JE_PASSE_MON_ANNEE
    JE_VAIS_BOSSER_CETTE_SEMAINE
    ONE_POINT
    PAS_TERRIBLE
    SERIEUX
    TROEUW

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation
Rule 4     statement -> declaration
Rule 5     statement -> structure
Rule 6     statement -> PAS_MAL expression
Rule 7     structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme }
Rule 8     expression -> expression ADD_OP expression
Rule 9     expression -> expression MUL_OP expression
Rule 10    expression -> NUMBER
Rule 11    expression -> INT
Rule 12    expression -> boolean
Rule 13    expression -> IDENTIFIER
Rule 14    boolean -> TRUE
Rule 15    boolean -> FALSE
Rule 16    expression -> ( expression )
Rule 17    expression -> ADD_OP expression
Rule 18    declaration -> TYPE IDENTIFIER
Rule 19    assignation -> IDENTIFIER = expression

Terminals, with rules where they appear

(                    : 16
)                    : 16
;                    : 2
=                    : 19
ADD_OP               : 8 17
BOOL                 : 
COCHON_EGAL_PORC     : 
FALSE                : 15
FERMEZ_VOS_ORDINATEUR : 
IDENTIFIER           : 13 18 19
INT                  : 11
JE_PASSE_MON_ANNEE   : 
JE_VAIS_BOSSER_CETTE_SEMAINE : 
MUL_OP               : 9
NUMBER               : 10
ONE_POINT            : 
ON_SE_LE_REFAIT_UNE_PETITE_FOIS : 7
PAS_MAL              : 6
PAS_TERRIBLE         : 
SERIEUX              : 
TROEUW               : 
TRUE                 : 14
TYPE                 : 18
error                : 
{                    : 7
}                    : 7

Nonterminals, with rules where they appear

assignation          : 3
boolean              : 12
declaration          : 4
expression           : 6 7 8 8 9 9 16 17 19
programme            : 2 7 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . ; programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 10


state 3

    (3) statement -> assignation .

    ;               reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> declaration .

    ;               reduce using rule 4 (statement -> declaration .)
    $end            reduce using rule 4 (statement -> declaration .)
    }               reduce using rule 4 (statement -> declaration .)


state 5

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 6

    (6) statement -> PAS_MAL . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 11
    boolean                        shift and go to state 15

state 7

    (19) assignation -> IDENTIFIER . = expression

    =               shift and go to state 20


state 8

    (18) declaration -> TYPE . IDENTIFIER

    IDENTIFIER      shift and go to state 21


state 9

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS . expression { programme }
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 22
    boolean                        shift and go to state 15

state 10

    (2) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9

    statement                      shift and go to state 2
    programme                      shift and go to state 23
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 11

    (6) statement -> PAS_MAL expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 6 (statement -> PAS_MAL expression .)
    $end            reduce using rule 6 (statement -> PAS_MAL expression .)
    }               reduce using rule 6 (statement -> PAS_MAL expression .)
    ADD_OP          shift and go to state 24
    MUL_OP          shift and go to state 25


state 12

    (17) expression -> ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 26
    boolean                        shift and go to state 15

state 13

    (10) expression -> NUMBER .

    ADD_OP          reduce using rule 10 (expression -> NUMBER .)
    MUL_OP          reduce using rule 10 (expression -> NUMBER .)
    ;               reduce using rule 10 (expression -> NUMBER .)
    $end            reduce using rule 10 (expression -> NUMBER .)
    }               reduce using rule 10 (expression -> NUMBER .)
    {               reduce using rule 10 (expression -> NUMBER .)
    )               reduce using rule 10 (expression -> NUMBER .)


state 14

    (11) expression -> INT .

    ADD_OP          reduce using rule 11 (expression -> INT .)
    MUL_OP          reduce using rule 11 (expression -> INT .)
    ;               reduce using rule 11 (expression -> INT .)
    $end            reduce using rule 11 (expression -> INT .)
    }               reduce using rule 11 (expression -> INT .)
    {               reduce using rule 11 (expression -> INT .)
    )               reduce using rule 11 (expression -> INT .)


state 15

    (12) expression -> boolean .

    ADD_OP          reduce using rule 12 (expression -> boolean .)
    MUL_OP          reduce using rule 12 (expression -> boolean .)
    ;               reduce using rule 12 (expression -> boolean .)
    $end            reduce using rule 12 (expression -> boolean .)
    }               reduce using rule 12 (expression -> boolean .)
    {               reduce using rule 12 (expression -> boolean .)
    )               reduce using rule 12 (expression -> boolean .)


state 16

    (13) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 13 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 13 (expression -> IDENTIFIER .)
    ;               reduce using rule 13 (expression -> IDENTIFIER .)
    $end            reduce using rule 13 (expression -> IDENTIFIER .)
    }               reduce using rule 13 (expression -> IDENTIFIER .)
    {               reduce using rule 13 (expression -> IDENTIFIER .)
    )               reduce using rule 13 (expression -> IDENTIFIER .)


state 17

    (16) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 27
    boolean                        shift and go to state 15

state 18

    (14) boolean -> TRUE .

    ADD_OP          reduce using rule 14 (boolean -> TRUE .)
    MUL_OP          reduce using rule 14 (boolean -> TRUE .)
    ;               reduce using rule 14 (boolean -> TRUE .)
    $end            reduce using rule 14 (boolean -> TRUE .)
    }               reduce using rule 14 (boolean -> TRUE .)
    {               reduce using rule 14 (boolean -> TRUE .)
    )               reduce using rule 14 (boolean -> TRUE .)


state 19

    (15) boolean -> FALSE .

    ADD_OP          reduce using rule 15 (boolean -> FALSE .)
    MUL_OP          reduce using rule 15 (boolean -> FALSE .)
    ;               reduce using rule 15 (boolean -> FALSE .)
    $end            reduce using rule 15 (boolean -> FALSE .)
    }               reduce using rule 15 (boolean -> FALSE .)
    {               reduce using rule 15 (boolean -> FALSE .)
    )               reduce using rule 15 (boolean -> FALSE .)


state 20

    (19) assignation -> IDENTIFIER = . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 28
    boolean                        shift and go to state 15

state 21

    (18) declaration -> TYPE IDENTIFIER .

    ;               reduce using rule 18 (declaration -> TYPE IDENTIFIER .)
    $end            reduce using rule 18 (declaration -> TYPE IDENTIFIER .)
    }               reduce using rule 18 (declaration -> TYPE IDENTIFIER .)


state 22

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression . { programme }
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    {               shift and go to state 29
    ADD_OP          shift and go to state 24
    MUL_OP          shift and go to state 25


state 23

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 24

    (8) expression -> expression ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 30
    boolean                        shift and go to state 15

state 25

    (9) expression -> expression MUL_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 13
    INT             shift and go to state 14
    IDENTIFIER      shift and go to state 16
    (               shift and go to state 17
    ADD_OP          shift and go to state 12
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    expression                     shift and go to state 31
    boolean                        shift and go to state 15

state 26

    (17) expression -> ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    ;               reduce using rule 17 (expression -> ADD_OP expression .)
    $end            reduce using rule 17 (expression -> ADD_OP expression .)
    }               reduce using rule 17 (expression -> ADD_OP expression .)
    {               reduce using rule 17 (expression -> ADD_OP expression .)
    )               reduce using rule 17 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 24 ]
  ! MUL_OP          [ shift and go to state 25 ]


state 27

    (16) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 32
    ADD_OP          shift and go to state 24
    MUL_OP          shift and go to state 25


state 28

    (19) assignation -> IDENTIFIER = expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 24
    MUL_OP          shift and go to state 25


state 29

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9

    programme                      shift and go to state 33
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 30

    (8) expression -> expression ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 8 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 8 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 8 (expression -> expression ADD_OP expression .)
    }               reduce using rule 8 (expression -> expression ADD_OP expression .)
    {               reduce using rule 8 (expression -> expression ADD_OP expression .)
    )               reduce using rule 8 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 25

  ! MUL_OP          [ reduce using rule 8 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 24 ]


state 31

    (9) expression -> expression MUL_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 9 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 9 (expression -> expression MUL_OP expression .)
    }               reduce using rule 9 (expression -> expression MUL_OP expression .)
    {               reduce using rule 9 (expression -> expression MUL_OP expression .)
    )               reduce using rule 9 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 24 ]
  ! MUL_OP          [ shift and go to state 25 ]


state 32

    (16) expression -> ( expression ) .

    ADD_OP          reduce using rule 16 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 16 (expression -> ( expression ) .)
    ;               reduce using rule 16 (expression -> ( expression ) .)
    $end            reduce using rule 16 (expression -> ( expression ) .)
    }               reduce using rule 16 (expression -> ( expression ) .)
    {               reduce using rule 16 (expression -> ( expression ) .)
    )               reduce using rule 16 (expression -> ( expression ) .)


state 33

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme . }

    }               shift and go to state 34


state 34

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme } .

    ;               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme } .)
    $end            reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme } .)
    }               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS expression { programme } .)

