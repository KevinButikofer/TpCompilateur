Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ONE_POINT
    PAS_TERRIBLE
    TROEUW

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation
Rule 4     statement -> declaration
Rule 5     statement -> structure
Rule 6     statement -> PAS_MAL expression
Rule 7     structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
Rule 8     expression -> expression ADD_OP expression
Rule 9     expression -> expression MUL_OP expression
Rule 10    expression -> NUMBER
Rule 11    expression -> INT
Rule 12    expression -> boolean
Rule 13    expression -> STRING
Rule 14    expression -> IDENTIFIER
Rule 15    boolean -> TRUE
Rule 16    boolean -> FALSE
Rule 17    expression -> ( expression )
Rule 18    expression -> ADD_OP expression
Rule 19    assignation -> IDENTIFIER INCREMENT_OP
Rule 20    declaration -> TYPE IDENTIFIER
Rule 21    assignation -> IDENTIFIER = expression
Rule 22    condition -> ( expression COMPARISONOP expression )
Rule 23    condition -> expression COMPARISONOP expression
Rule 24    structure -> SERIEUX condition { programme }
Rule 25    structure -> SERIEUX condition { programme } ELSE { programme }
Rule 26    structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

Terminals, with rules where they appear

(                    : 17 22 26
)                    : 17 22 26
;                    : 2 26 26
=                    : 21
ADD_OP               : 8 18
COMPARISONOP         : 22 23
C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON : 26
ELSE                 : 25
FALSE                : 16
IDENTIFIER           : 14 19 20 21
INCREMENT_OP         : 19
INT                  : 11
MUL_OP               : 9
NUMBER               : 10
ONE_POINT            : 
ON_SE_LE_REFAIT_UNE_PETITE_FOIS : 7
PAS_MAL              : 6
PAS_TERRIBLE         : 
SERIEUX              : 24 25
STRING               : 13
TROEUW               : 
TRUE                 : 15
TYPE                 : 20
error                : 
{                    : 7 24 25 25 26
}                    : 7 24 25 25 26

Nonterminals, with rules where they appear

assignation          : 3 26 26
boolean              : 12
condition            : 7 24 25 26
declaration          : 4
expression           : 6 8 8 9 9 17 18 21 22 22 23 23
programme            : 2 7 24 25 25 26 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression
    (20) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (24) structure -> . SERIEUX condition { programme }
    (25) structure -> . SERIEUX condition { programme } ELSE { programme }
    (26) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . ; programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 12


state 3

    (3) statement -> assignation .

    ;               reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> declaration .

    ;               reduce using rule 4 (statement -> declaration .)
    $end            reduce using rule 4 (statement -> declaration .)
    }               reduce using rule 4 (statement -> declaration .)


state 5

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 6

    (6) statement -> PAS_MAL . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 13
    boolean                        shift and go to state 17

state 7

    (19) assignation -> IDENTIFIER . INCREMENT_OP
    (21) assignation -> IDENTIFIER . = expression

    INCREMENT_OP    shift and go to state 23
    =               shift and go to state 24


state 8

    (20) declaration -> TYPE . IDENTIFIER

    IDENTIFIER      shift and go to state 25


state 9

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS . condition { programme }
    (22) condition -> . ( expression COMPARISONOP expression )
    (23) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    (               shift and go to state 27
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    condition                      shift and go to state 26
    expression                     shift and go to state 28
    boolean                        shift and go to state 17

state 10

    (24) structure -> SERIEUX . condition { programme }
    (25) structure -> SERIEUX . condition { programme } ELSE { programme }
    (22) condition -> . ( expression COMPARISONOP expression )
    (23) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    (               shift and go to state 27
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    condition                      shift and go to state 29
    expression                     shift and go to state 28
    boolean                        shift and go to state 17

state 11

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON . ( assignation ; condition ; assignation ) { programme }

    (               shift and go to state 30


state 12

    (2) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression
    (20) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (24) structure -> . SERIEUX condition { programme }
    (25) structure -> . SERIEUX condition { programme } ELSE { programme }
    (26) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    statement                      shift and go to state 2
    programme                      shift and go to state 31
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 13

    (6) statement -> PAS_MAL expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 6 (statement -> PAS_MAL expression .)
    $end            reduce using rule 6 (statement -> PAS_MAL expression .)
    }               reduce using rule 6 (statement -> PAS_MAL expression .)
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 14

    (18) expression -> ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 34
    boolean                        shift and go to state 17

state 15

    (10) expression -> NUMBER .

    ADD_OP          reduce using rule 10 (expression -> NUMBER .)
    MUL_OP          reduce using rule 10 (expression -> NUMBER .)
    ;               reduce using rule 10 (expression -> NUMBER .)
    $end            reduce using rule 10 (expression -> NUMBER .)
    }               reduce using rule 10 (expression -> NUMBER .)
    COMPARISONOP    reduce using rule 10 (expression -> NUMBER .)
    )               reduce using rule 10 (expression -> NUMBER .)
    {               reduce using rule 10 (expression -> NUMBER .)


state 16

    (11) expression -> INT .

    ADD_OP          reduce using rule 11 (expression -> INT .)
    MUL_OP          reduce using rule 11 (expression -> INT .)
    ;               reduce using rule 11 (expression -> INT .)
    $end            reduce using rule 11 (expression -> INT .)
    }               reduce using rule 11 (expression -> INT .)
    COMPARISONOP    reduce using rule 11 (expression -> INT .)
    )               reduce using rule 11 (expression -> INT .)
    {               reduce using rule 11 (expression -> INT .)


state 17

    (12) expression -> boolean .

    ADD_OP          reduce using rule 12 (expression -> boolean .)
    MUL_OP          reduce using rule 12 (expression -> boolean .)
    ;               reduce using rule 12 (expression -> boolean .)
    $end            reduce using rule 12 (expression -> boolean .)
    }               reduce using rule 12 (expression -> boolean .)
    COMPARISONOP    reduce using rule 12 (expression -> boolean .)
    )               reduce using rule 12 (expression -> boolean .)
    {               reduce using rule 12 (expression -> boolean .)


state 18

    (13) expression -> STRING .

    ADD_OP          reduce using rule 13 (expression -> STRING .)
    MUL_OP          reduce using rule 13 (expression -> STRING .)
    ;               reduce using rule 13 (expression -> STRING .)
    $end            reduce using rule 13 (expression -> STRING .)
    }               reduce using rule 13 (expression -> STRING .)
    COMPARISONOP    reduce using rule 13 (expression -> STRING .)
    )               reduce using rule 13 (expression -> STRING .)
    {               reduce using rule 13 (expression -> STRING .)


state 19

    (14) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 14 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 14 (expression -> IDENTIFIER .)
    ;               reduce using rule 14 (expression -> IDENTIFIER .)
    $end            reduce using rule 14 (expression -> IDENTIFIER .)
    }               reduce using rule 14 (expression -> IDENTIFIER .)
    COMPARISONOP    reduce using rule 14 (expression -> IDENTIFIER .)
    )               reduce using rule 14 (expression -> IDENTIFIER .)
    {               reduce using rule 14 (expression -> IDENTIFIER .)


state 20

    (17) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 35
    boolean                        shift and go to state 17

state 21

    (15) boolean -> TRUE .

    ADD_OP          reduce using rule 15 (boolean -> TRUE .)
    MUL_OP          reduce using rule 15 (boolean -> TRUE .)
    ;               reduce using rule 15 (boolean -> TRUE .)
    $end            reduce using rule 15 (boolean -> TRUE .)
    }               reduce using rule 15 (boolean -> TRUE .)
    COMPARISONOP    reduce using rule 15 (boolean -> TRUE .)
    )               reduce using rule 15 (boolean -> TRUE .)
    {               reduce using rule 15 (boolean -> TRUE .)


state 22

    (16) boolean -> FALSE .

    ADD_OP          reduce using rule 16 (boolean -> FALSE .)
    MUL_OP          reduce using rule 16 (boolean -> FALSE .)
    ;               reduce using rule 16 (boolean -> FALSE .)
    $end            reduce using rule 16 (boolean -> FALSE .)
    }               reduce using rule 16 (boolean -> FALSE .)
    COMPARISONOP    reduce using rule 16 (boolean -> FALSE .)
    )               reduce using rule 16 (boolean -> FALSE .)
    {               reduce using rule 16 (boolean -> FALSE .)


state 23

    (19) assignation -> IDENTIFIER INCREMENT_OP .

    ;               reduce using rule 19 (assignation -> IDENTIFIER INCREMENT_OP .)
    $end            reduce using rule 19 (assignation -> IDENTIFIER INCREMENT_OP .)
    }               reduce using rule 19 (assignation -> IDENTIFIER INCREMENT_OP .)
    )               reduce using rule 19 (assignation -> IDENTIFIER INCREMENT_OP .)


state 24

    (21) assignation -> IDENTIFIER = . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 36
    boolean                        shift and go to state 17

state 25

    (20) declaration -> TYPE IDENTIFIER .

    ;               reduce using rule 20 (declaration -> TYPE IDENTIFIER .)
    $end            reduce using rule 20 (declaration -> TYPE IDENTIFIER .)
    }               reduce using rule 20 (declaration -> TYPE IDENTIFIER .)


state 26

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition . { programme }

    {               shift and go to state 37


state 27

    (22) condition -> ( . expression COMPARISONOP expression )
    (17) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 38
    boolean                        shift and go to state 17

state 28

    (23) condition -> expression . COMPARISONOP expression
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    COMPARISONOP    shift and go to state 39
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 29

    (24) structure -> SERIEUX condition . { programme }
    (25) structure -> SERIEUX condition . { programme } ELSE { programme }

    {               shift and go to state 40


state 30

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( . assignation ; condition ; assignation ) { programme }
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 7

    assignation                    shift and go to state 41

state 31

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 32

    (8) expression -> expression ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 42
    boolean                        shift and go to state 17

state 33

    (9) expression -> expression MUL_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 43
    boolean                        shift and go to state 17

state 34

    (18) expression -> ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 18 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 18 (expression -> ADD_OP expression .)
    ;               reduce using rule 18 (expression -> ADD_OP expression .)
    $end            reduce using rule 18 (expression -> ADD_OP expression .)
    }               reduce using rule 18 (expression -> ADD_OP expression .)
    COMPARISONOP    reduce using rule 18 (expression -> ADD_OP expression .)
    )               reduce using rule 18 (expression -> ADD_OP expression .)
    {               reduce using rule 18 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 32 ]
  ! MUL_OP          [ shift and go to state 33 ]


state 35

    (17) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 44
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 36

    (21) assignation -> IDENTIFIER = expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    )               reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 37

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression
    (20) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (24) structure -> . SERIEUX condition { programme }
    (25) structure -> . SERIEUX condition { programme } ELSE { programme }
    (26) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 45
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 38

    (22) condition -> ( expression . COMPARISONOP expression )
    (17) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    COMPARISONOP    shift and go to state 46
    )               shift and go to state 44
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 39

    (23) condition -> expression COMPARISONOP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 47
    boolean                        shift and go to state 17

state 40

    (24) structure -> SERIEUX condition { . programme }
    (25) structure -> SERIEUX condition { . programme } ELSE { programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression
    (20) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (24) structure -> . SERIEUX condition { programme }
    (25) structure -> . SERIEUX condition { programme } ELSE { programme }
    (26) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 48
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 41

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation . ; condition ; assignation ) { programme }

    ;               shift and go to state 49


state 42

    (8) expression -> expression ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 8 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 8 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 8 (expression -> expression ADD_OP expression .)
    }               reduce using rule 8 (expression -> expression ADD_OP expression .)
    COMPARISONOP    reduce using rule 8 (expression -> expression ADD_OP expression .)
    )               reduce using rule 8 (expression -> expression ADD_OP expression .)
    {               reduce using rule 8 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 33

  ! MUL_OP          [ reduce using rule 8 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 32 ]


state 43

    (9) expression -> expression MUL_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 9 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 9 (expression -> expression MUL_OP expression .)
    }               reduce using rule 9 (expression -> expression MUL_OP expression .)
    COMPARISONOP    reduce using rule 9 (expression -> expression MUL_OP expression .)
    )               reduce using rule 9 (expression -> expression MUL_OP expression .)
    {               reduce using rule 9 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 32 ]
  ! MUL_OP          [ shift and go to state 33 ]


state 44

    (17) expression -> ( expression ) .

    ADD_OP          reduce using rule 17 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 17 (expression -> ( expression ) .)
    ;               reduce using rule 17 (expression -> ( expression ) .)
    $end            reduce using rule 17 (expression -> ( expression ) .)
    }               reduce using rule 17 (expression -> ( expression ) .)
    COMPARISONOP    reduce using rule 17 (expression -> ( expression ) .)
    )               reduce using rule 17 (expression -> ( expression ) .)
    {               reduce using rule 17 (expression -> ( expression ) .)


state 45

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme . }

    }               shift and go to state 50


state 46

    (22) condition -> ( expression COMPARISONOP . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 51
    boolean                        shift and go to state 17

state 47

    (23) condition -> expression COMPARISONOP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    {               reduce using rule 23 (condition -> expression COMPARISONOP expression .)
    ;               reduce using rule 23 (condition -> expression COMPARISONOP expression .)
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 48

    (24) structure -> SERIEUX condition { programme . }
    (25) structure -> SERIEUX condition { programme . } ELSE { programme }

    }               shift and go to state 52


state 49

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; . condition ; assignation ) { programme }
    (22) condition -> . ( expression COMPARISONOP expression )
    (23) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    (               shift and go to state 27
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    condition                      shift and go to state 53
    expression                     shift and go to state 28
    boolean                        shift and go to state 17

state 50

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .

    ;               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)
    $end            reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)
    }               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)


state 51

    (22) condition -> ( expression COMPARISONOP expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 54
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 52

    (24) structure -> SERIEUX condition { programme } .
    (25) structure -> SERIEUX condition { programme } . ELSE { programme }

    ;               reduce using rule 24 (structure -> SERIEUX condition { programme } .)
    $end            reduce using rule 24 (structure -> SERIEUX condition { programme } .)
    }               reduce using rule 24 (structure -> SERIEUX condition { programme } .)
    ELSE            shift and go to state 55


state 53

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition . ; assignation ) { programme }

    ;               shift and go to state 56


state 54

    (22) condition -> ( expression COMPARISONOP expression ) .

    {               reduce using rule 22 (condition -> ( expression COMPARISONOP expression ) .)
    ;               reduce using rule 22 (condition -> ( expression COMPARISONOP expression ) .)


state 55

    (25) structure -> SERIEUX condition { programme } ELSE . { programme }

    {               shift and go to state 57


state 56

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; . assignation ) { programme }
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 7

    assignation                    shift and go to state 58

state 57

    (25) structure -> SERIEUX condition { programme } ELSE { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression
    (20) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (24) structure -> . SERIEUX condition { programme }
    (25) structure -> . SERIEUX condition { programme } ELSE { programme }
    (26) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 59
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 58

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation . ) { programme }

    )               shift and go to state 60


state 59

    (25) structure -> SERIEUX condition { programme } ELSE { programme . }

    }               shift and go to state 61


state 60

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) . { programme }

    {               shift and go to state 62


state 61

    (25) structure -> SERIEUX condition { programme } ELSE { programme } .

    ;               reduce using rule 25 (structure -> SERIEUX condition { programme } ELSE { programme } .)
    $end            reduce using rule 25 (structure -> SERIEUX condition { programme } ELSE { programme } .)
    }               reduce using rule 25 (structure -> SERIEUX condition { programme } ELSE { programme } .)


state 62

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER INCREMENT_OP
    (21) assignation -> . IDENTIFIER = expression
    (20) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (24) structure -> . SERIEUX condition { programme }
    (25) structure -> . SERIEUX condition { programme } ELSE { programme }
    (26) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    assignation                    shift and go to state 3
    programme                      shift and go to state 63
    statement                      shift and go to state 2
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 63

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme . }

    }               shift and go to state 64


state 64

    (26) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .

    ;               reduce using rule 26 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)
    $end            reduce using rule 26 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)
    }               reduce using rule 26 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)

