Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    COCHON_EGAL_PORC
    FERMEZ_VOS_ORDINATEUR
    JE_PASSE_MON_ANNEE
    JE_VAIS_BOSSER_CETTE_SEMAINE
    ONE_POINT
    PAS_TERRIBLE
    TROEUW

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation
Rule 4     statement -> declaration
Rule 5     statement -> structure
Rule 6     statement -> PAS_MAL expression
Rule 7     structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
Rule 8     expression -> expression ADD_OP expression
Rule 9     expression -> expression MUL_OP expression
Rule 10    expression -> NUMBER
Rule 11    expression -> INT
Rule 12    expression -> boolean
Rule 13    expression -> STRING
Rule 14    expression -> IDENTIFIER
Rule 15    boolean -> TRUE
Rule 16    boolean -> FALSE
Rule 17    expression -> ( expression )
Rule 18    expression -> ADD_OP expression
Rule 19    declaration -> TYPE IDENTIFIER
Rule 20    assignation -> IDENTIFIER = expression
Rule 21    condition -> ( expression COMPARISONOP expression )
Rule 22    condition -> expression COMPARISONOP expression
Rule 23    structure -> SERIEUX condition { programme }
Rule 24    structure -> SERIEUX condition { programme } ELSE { programme }
Rule 25    structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

Terminals, with rules where they appear

(                    : 17 21 25
)                    : 17 21 25
;                    : 2 25 25
=                    : 20
ADD_OP               : 8 18
BOOL                 : 
COCHON_EGAL_PORC     : 
COMPARISONOP         : 21 22
C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON : 25
ELSE                 : 24
FALSE                : 16
FERMEZ_VOS_ORDINATEUR : 
IDENTIFIER           : 14 19 20
INT                  : 11
JE_PASSE_MON_ANNEE   : 
JE_VAIS_BOSSER_CETTE_SEMAINE : 
MUL_OP               : 9
NUMBER               : 10
ONE_POINT            : 
ON_SE_LE_REFAIT_UNE_PETITE_FOIS : 7
PAS_MAL              : 6
PAS_TERRIBLE         : 
SERIEUX              : 23 24
STRING               : 13
TROEUW               : 
TRUE                 : 15
TYPE                 : 19
error                : 
{                    : 7 23 24 24 25
}                    : 7 23 24 24 25

Nonterminals, with rules where they appear

assignation          : 3 25 25
boolean              : 12
condition            : 7 23 24 25
declaration          : 4
expression           : 6 8 8 9 9 17 18 20 21 21 22 22
programme            : 2 7 23 24 24 25 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (20) assignation -> . IDENTIFIER = expression
    (19) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (23) structure -> . SERIEUX condition { programme }
    (24) structure -> . SERIEUX condition { programme } ELSE { programme }
    (25) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . ; programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 12


state 3

    (3) statement -> assignation .

    ;               reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> declaration .

    ;               reduce using rule 4 (statement -> declaration .)
    $end            reduce using rule 4 (statement -> declaration .)
    }               reduce using rule 4 (statement -> declaration .)


state 5

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 6

    (6) statement -> PAS_MAL . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 13
    boolean                        shift and go to state 17

state 7

    (20) assignation -> IDENTIFIER . = expression

    =               shift and go to state 23


state 8

    (19) declaration -> TYPE . IDENTIFIER

    IDENTIFIER      shift and go to state 24


state 9

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS . condition { programme }
    (21) condition -> . ( expression COMPARISONOP expression )
    (22) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    (               shift and go to state 26
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    condition                      shift and go to state 25
    expression                     shift and go to state 27
    boolean                        shift and go to state 17

state 10

    (23) structure -> SERIEUX . condition { programme }
    (24) structure -> SERIEUX . condition { programme } ELSE { programme }
    (21) condition -> . ( expression COMPARISONOP expression )
    (22) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    (               shift and go to state 26
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    condition                      shift and go to state 28
    expression                     shift and go to state 27
    boolean                        shift and go to state 17

state 11

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON . ( assignation ; condition ; assignation ) { programme }

    (               shift and go to state 29


state 12

    (2) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (20) assignation -> . IDENTIFIER = expression
    (19) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (23) structure -> . SERIEUX condition { programme }
    (24) structure -> . SERIEUX condition { programme } ELSE { programme }
    (25) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    statement                      shift and go to state 2
    programme                      shift and go to state 30
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 13

    (6) statement -> PAS_MAL expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 6 (statement -> PAS_MAL expression .)
    $end            reduce using rule 6 (statement -> PAS_MAL expression .)
    }               reduce using rule 6 (statement -> PAS_MAL expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 14

    (18) expression -> ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 33
    boolean                        shift and go to state 17

state 15

    (10) expression -> NUMBER .

    ADD_OP          reduce using rule 10 (expression -> NUMBER .)
    MUL_OP          reduce using rule 10 (expression -> NUMBER .)
    ;               reduce using rule 10 (expression -> NUMBER .)
    $end            reduce using rule 10 (expression -> NUMBER .)
    }               reduce using rule 10 (expression -> NUMBER .)
    COMPARISONOP    reduce using rule 10 (expression -> NUMBER .)
    )               reduce using rule 10 (expression -> NUMBER .)
    {               reduce using rule 10 (expression -> NUMBER .)


state 16

    (11) expression -> INT .

    ADD_OP          reduce using rule 11 (expression -> INT .)
    MUL_OP          reduce using rule 11 (expression -> INT .)
    ;               reduce using rule 11 (expression -> INT .)
    $end            reduce using rule 11 (expression -> INT .)
    }               reduce using rule 11 (expression -> INT .)
    COMPARISONOP    reduce using rule 11 (expression -> INT .)
    )               reduce using rule 11 (expression -> INT .)
    {               reduce using rule 11 (expression -> INT .)


state 17

    (12) expression -> boolean .

    ADD_OP          reduce using rule 12 (expression -> boolean .)
    MUL_OP          reduce using rule 12 (expression -> boolean .)
    ;               reduce using rule 12 (expression -> boolean .)
    $end            reduce using rule 12 (expression -> boolean .)
    }               reduce using rule 12 (expression -> boolean .)
    COMPARISONOP    reduce using rule 12 (expression -> boolean .)
    )               reduce using rule 12 (expression -> boolean .)
    {               reduce using rule 12 (expression -> boolean .)


state 18

    (13) expression -> STRING .

    ADD_OP          reduce using rule 13 (expression -> STRING .)
    MUL_OP          reduce using rule 13 (expression -> STRING .)
    ;               reduce using rule 13 (expression -> STRING .)
    $end            reduce using rule 13 (expression -> STRING .)
    }               reduce using rule 13 (expression -> STRING .)
    COMPARISONOP    reduce using rule 13 (expression -> STRING .)
    )               reduce using rule 13 (expression -> STRING .)
    {               reduce using rule 13 (expression -> STRING .)


state 19

    (14) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 14 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 14 (expression -> IDENTIFIER .)
    ;               reduce using rule 14 (expression -> IDENTIFIER .)
    $end            reduce using rule 14 (expression -> IDENTIFIER .)
    }               reduce using rule 14 (expression -> IDENTIFIER .)
    COMPARISONOP    reduce using rule 14 (expression -> IDENTIFIER .)
    )               reduce using rule 14 (expression -> IDENTIFIER .)
    {               reduce using rule 14 (expression -> IDENTIFIER .)


state 20

    (17) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 34
    boolean                        shift and go to state 17

state 21

    (15) boolean -> TRUE .

    ADD_OP          reduce using rule 15 (boolean -> TRUE .)
    MUL_OP          reduce using rule 15 (boolean -> TRUE .)
    ;               reduce using rule 15 (boolean -> TRUE .)
    $end            reduce using rule 15 (boolean -> TRUE .)
    }               reduce using rule 15 (boolean -> TRUE .)
    COMPARISONOP    reduce using rule 15 (boolean -> TRUE .)
    )               reduce using rule 15 (boolean -> TRUE .)
    {               reduce using rule 15 (boolean -> TRUE .)


state 22

    (16) boolean -> FALSE .

    ADD_OP          reduce using rule 16 (boolean -> FALSE .)
    MUL_OP          reduce using rule 16 (boolean -> FALSE .)
    ;               reduce using rule 16 (boolean -> FALSE .)
    $end            reduce using rule 16 (boolean -> FALSE .)
    }               reduce using rule 16 (boolean -> FALSE .)
    COMPARISONOP    reduce using rule 16 (boolean -> FALSE .)
    )               reduce using rule 16 (boolean -> FALSE .)
    {               reduce using rule 16 (boolean -> FALSE .)


state 23

    (20) assignation -> IDENTIFIER = . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 35
    boolean                        shift and go to state 17

state 24

    (19) declaration -> TYPE IDENTIFIER .

    ;               reduce using rule 19 (declaration -> TYPE IDENTIFIER .)
    $end            reduce using rule 19 (declaration -> TYPE IDENTIFIER .)
    }               reduce using rule 19 (declaration -> TYPE IDENTIFIER .)


state 25

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition . { programme }

    {               shift and go to state 36


state 26

    (21) condition -> ( . expression COMPARISONOP expression )
    (17) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 37
    boolean                        shift and go to state 17

state 27

    (22) condition -> expression . COMPARISONOP expression
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    COMPARISONOP    shift and go to state 38
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 28

    (23) structure -> SERIEUX condition . { programme }
    (24) structure -> SERIEUX condition . { programme } ELSE { programme }

    {               shift and go to state 39


state 29

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( . assignation ; condition ; assignation ) { programme }
    (20) assignation -> . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 7

    assignation                    shift and go to state 40

state 30

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 31

    (8) expression -> expression ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 41
    boolean                        shift and go to state 17

state 32

    (9) expression -> expression MUL_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 42
    boolean                        shift and go to state 17

state 33

    (18) expression -> ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 18 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 18 (expression -> ADD_OP expression .)
    ;               reduce using rule 18 (expression -> ADD_OP expression .)
    $end            reduce using rule 18 (expression -> ADD_OP expression .)
    }               reduce using rule 18 (expression -> ADD_OP expression .)
    COMPARISONOP    reduce using rule 18 (expression -> ADD_OP expression .)
    )               reduce using rule 18 (expression -> ADD_OP expression .)
    {               reduce using rule 18 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 31 ]
  ! MUL_OP          [ shift and go to state 32 ]


state 34

    (17) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 43
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 35

    (20) assignation -> IDENTIFIER = expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    )               reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 36

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (20) assignation -> . IDENTIFIER = expression
    (19) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (23) structure -> . SERIEUX condition { programme }
    (24) structure -> . SERIEUX condition { programme } ELSE { programme }
    (25) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 44
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 37

    (21) condition -> ( expression . COMPARISONOP expression )
    (17) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    COMPARISONOP    shift and go to state 45
    )               shift and go to state 43
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 38

    (22) condition -> expression COMPARISONOP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 46
    boolean                        shift and go to state 17

state 39

    (23) structure -> SERIEUX condition { . programme }
    (24) structure -> SERIEUX condition { . programme } ELSE { programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (20) assignation -> . IDENTIFIER = expression
    (19) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (23) structure -> . SERIEUX condition { programme }
    (24) structure -> . SERIEUX condition { programme } ELSE { programme }
    (25) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 47
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 40

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation . ; condition ; assignation ) { programme }

    ;               shift and go to state 48


state 41

    (8) expression -> expression ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 8 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 8 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 8 (expression -> expression ADD_OP expression .)
    }               reduce using rule 8 (expression -> expression ADD_OP expression .)
    COMPARISONOP    reduce using rule 8 (expression -> expression ADD_OP expression .)
    )               reduce using rule 8 (expression -> expression ADD_OP expression .)
    {               reduce using rule 8 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 32

  ! MUL_OP          [ reduce using rule 8 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 31 ]


state 42

    (9) expression -> expression MUL_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 9 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 9 (expression -> expression MUL_OP expression .)
    }               reduce using rule 9 (expression -> expression MUL_OP expression .)
    COMPARISONOP    reduce using rule 9 (expression -> expression MUL_OP expression .)
    )               reduce using rule 9 (expression -> expression MUL_OP expression .)
    {               reduce using rule 9 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 31 ]
  ! MUL_OP          [ shift and go to state 32 ]


state 43

    (17) expression -> ( expression ) .

    ADD_OP          reduce using rule 17 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 17 (expression -> ( expression ) .)
    ;               reduce using rule 17 (expression -> ( expression ) .)
    $end            reduce using rule 17 (expression -> ( expression ) .)
    }               reduce using rule 17 (expression -> ( expression ) .)
    COMPARISONOP    reduce using rule 17 (expression -> ( expression ) .)
    )               reduce using rule 17 (expression -> ( expression ) .)
    {               reduce using rule 17 (expression -> ( expression ) .)


state 44

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme . }

    }               shift and go to state 49


state 45

    (21) condition -> ( expression COMPARISONOP . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    (               shift and go to state 20
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 50
    boolean                        shift and go to state 17

state 46

    (22) condition -> expression COMPARISONOP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    {               reduce using rule 22 (condition -> expression COMPARISONOP expression .)
    ;               reduce using rule 22 (condition -> expression COMPARISONOP expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 47

    (23) structure -> SERIEUX condition { programme . }
    (24) structure -> SERIEUX condition { programme . } ELSE { programme }

    }               shift and go to state 51


state 48

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; . condition ; assignation ) { programme }
    (21) condition -> . ( expression COMPARISONOP expression )
    (22) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . STRING
    (14) expression -> . IDENTIFIER
    (17) expression -> . ( expression )
    (18) expression -> . ADD_OP expression
    (15) boolean -> . TRUE
    (16) boolean -> . FALSE

    (               shift and go to state 26
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    condition                      shift and go to state 52
    expression                     shift and go to state 27
    boolean                        shift and go to state 17

state 49

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .

    ;               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)
    $end            reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)
    }               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)


state 50

    (21) condition -> ( expression COMPARISONOP expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 53
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 51

    (23) structure -> SERIEUX condition { programme } .
    (24) structure -> SERIEUX condition { programme } . ELSE { programme }

    ;               reduce using rule 23 (structure -> SERIEUX condition { programme } .)
    $end            reduce using rule 23 (structure -> SERIEUX condition { programme } .)
    }               reduce using rule 23 (structure -> SERIEUX condition { programme } .)
    ELSE            shift and go to state 54


state 52

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition . ; assignation ) { programme }

    ;               shift and go to state 55


state 53

    (21) condition -> ( expression COMPARISONOP expression ) .

    {               reduce using rule 21 (condition -> ( expression COMPARISONOP expression ) .)
    ;               reduce using rule 21 (condition -> ( expression COMPARISONOP expression ) .)


state 54

    (24) structure -> SERIEUX condition { programme } ELSE . { programme }

    {               shift and go to state 56


state 55

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; . assignation ) { programme }
    (20) assignation -> . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 7

    assignation                    shift and go to state 57

state 56

    (24) structure -> SERIEUX condition { programme } ELSE { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (20) assignation -> . IDENTIFIER = expression
    (19) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (23) structure -> . SERIEUX condition { programme }
    (24) structure -> . SERIEUX condition { programme } ELSE { programme }
    (25) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 58
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 57

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation . ) { programme }

    )               shift and go to state 59


state 58

    (24) structure -> SERIEUX condition { programme } ELSE { programme . }

    }               shift and go to state 60


state 59

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) . { programme }

    {               shift and go to state 61


state 60

    (24) structure -> SERIEUX condition { programme } ELSE { programme } .

    ;               reduce using rule 24 (structure -> SERIEUX condition { programme } ELSE { programme } .)
    $end            reduce using rule 24 (structure -> SERIEUX condition { programme } ELSE { programme } .)
    }               reduce using rule 24 (structure -> SERIEUX condition { programme } ELSE { programme } .)


state 61

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (20) assignation -> . IDENTIFIER = expression
    (19) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (23) structure -> . SERIEUX condition { programme }
    (24) structure -> . SERIEUX condition { programme } ELSE { programme }
    (25) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    assignation                    shift and go to state 3
    programme                      shift and go to state 62
    statement                      shift and go to state 2
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 62

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme . }

    }               shift and go to state 63


state 63

    (25) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .

    ;               reduce using rule 25 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)
    $end            reduce using rule 25 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)
    }               reduce using rule 25 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)

