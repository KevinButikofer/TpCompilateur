Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    COCHON_EGAL_PORC
    FERMEZ_VOS_ORDINATEUR
    JE_PASSE_MON_ANNEE
    JE_VAIS_BOSSER_CETTE_SEMAINE
    ONE_POINT
    PAS_TERRIBLE
    TROEUW

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation
Rule 4     statement -> declaration
Rule 5     statement -> structure
Rule 6     statement -> PAS_MAL expression
Rule 7     structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
Rule 8     expression -> expression ADD_OP expression
Rule 9     expression -> expression MUL_OP expression
Rule 10    expression -> NUMBER
Rule 11    expression -> INT
Rule 12    expression -> boolean
Rule 13    expression -> IDENTIFIER
Rule 14    boolean -> TRUE
Rule 15    boolean -> FALSE
Rule 16    expression -> ( expression )
Rule 17    expression -> ADD_OP expression
Rule 18    declaration -> TYPE IDENTIFIER
Rule 19    assignation -> IDENTIFIER = expression
Rule 20    condition -> ( expression COMPARISONOP expression )
Rule 21    condition -> expression COMPARISONOP expression
Rule 22    structure -> SERIEUX condition { programme }
Rule 23    structure -> SERIEUX condition { programme } ELSE { programme }
Rule 24    structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

Terminals, with rules where they appear

(                    : 16 20 24
)                    : 16 20 24
;                    : 2 24 24
=                    : 19
ADD_OP               : 8 17
BOOL                 : 
COCHON_EGAL_PORC     : 
COMPARISONOP         : 20 21
C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON : 24
ELSE                 : 23
FALSE                : 15
FERMEZ_VOS_ORDINATEUR : 
IDENTIFIER           : 13 18 19
INT                  : 11
JE_PASSE_MON_ANNEE   : 
JE_VAIS_BOSSER_CETTE_SEMAINE : 
MUL_OP               : 9
NUMBER               : 10
ONE_POINT            : 
ON_SE_LE_REFAIT_UNE_PETITE_FOIS : 7
PAS_MAL              : 6
PAS_TERRIBLE         : 
SERIEUX              : 22 23
TROEUW               : 
TRUE                 : 14
TYPE                 : 18
error                : 
{                    : 7 22 23 23 24
}                    : 7 22 23 23 24

Nonterminals, with rules where they appear

assignation          : 3 24 24
boolean              : 12
condition            : 7 22 23 24
declaration          : 4
expression           : 6 8 8 9 9 16 17 19 20 20 21 21
programme            : 2 7 22 23 23 24 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (22) structure -> . SERIEUX condition { programme }
    (23) structure -> . SERIEUX condition { programme } ELSE { programme }
    (24) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . ; programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 12


state 3

    (3) statement -> assignation .

    ;               reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> declaration .

    ;               reduce using rule 4 (statement -> declaration .)
    $end            reduce using rule 4 (statement -> declaration .)
    }               reduce using rule 4 (statement -> declaration .)


state 5

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 6

    (6) statement -> PAS_MAL . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 13
    boolean                        shift and go to state 17

state 7

    (19) assignation -> IDENTIFIER . = expression

    =               shift and go to state 22


state 8

    (18) declaration -> TYPE . IDENTIFIER

    IDENTIFIER      shift and go to state 23


state 9

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS . condition { programme }
    (20) condition -> . ( expression COMPARISONOP expression )
    (21) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    (               shift and go to state 25
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    condition                      shift and go to state 24
    expression                     shift and go to state 26
    boolean                        shift and go to state 17

state 10

    (22) structure -> SERIEUX . condition { programme }
    (23) structure -> SERIEUX . condition { programme } ELSE { programme }
    (20) condition -> . ( expression COMPARISONOP expression )
    (21) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    (               shift and go to state 25
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    condition                      shift and go to state 27
    expression                     shift and go to state 26
    boolean                        shift and go to state 17

state 11

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON . ( assignation ; condition ; assignation ) { programme }

    (               shift and go to state 28


state 12

    (2) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (22) structure -> . SERIEUX condition { programme }
    (23) structure -> . SERIEUX condition { programme } ELSE { programme }
    (24) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    statement                      shift and go to state 2
    programme                      shift and go to state 29
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 13

    (6) statement -> PAS_MAL expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 6 (statement -> PAS_MAL expression .)
    $end            reduce using rule 6 (statement -> PAS_MAL expression .)
    }               reduce using rule 6 (statement -> PAS_MAL expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 14

    (17) expression -> ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 32
    boolean                        shift and go to state 17

state 15

    (10) expression -> NUMBER .

    ADD_OP          reduce using rule 10 (expression -> NUMBER .)
    MUL_OP          reduce using rule 10 (expression -> NUMBER .)
    ;               reduce using rule 10 (expression -> NUMBER .)
    $end            reduce using rule 10 (expression -> NUMBER .)
    }               reduce using rule 10 (expression -> NUMBER .)
    COMPARISONOP    reduce using rule 10 (expression -> NUMBER .)
    )               reduce using rule 10 (expression -> NUMBER .)
    {               reduce using rule 10 (expression -> NUMBER .)


state 16

    (11) expression -> INT .

    ADD_OP          reduce using rule 11 (expression -> INT .)
    MUL_OP          reduce using rule 11 (expression -> INT .)
    ;               reduce using rule 11 (expression -> INT .)
    $end            reduce using rule 11 (expression -> INT .)
    }               reduce using rule 11 (expression -> INT .)
    COMPARISONOP    reduce using rule 11 (expression -> INT .)
    )               reduce using rule 11 (expression -> INT .)
    {               reduce using rule 11 (expression -> INT .)


state 17

    (12) expression -> boolean .

    ADD_OP          reduce using rule 12 (expression -> boolean .)
    MUL_OP          reduce using rule 12 (expression -> boolean .)
    ;               reduce using rule 12 (expression -> boolean .)
    $end            reduce using rule 12 (expression -> boolean .)
    }               reduce using rule 12 (expression -> boolean .)
    COMPARISONOP    reduce using rule 12 (expression -> boolean .)
    )               reduce using rule 12 (expression -> boolean .)
    {               reduce using rule 12 (expression -> boolean .)


state 18

    (13) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 13 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 13 (expression -> IDENTIFIER .)
    ;               reduce using rule 13 (expression -> IDENTIFIER .)
    $end            reduce using rule 13 (expression -> IDENTIFIER .)
    }               reduce using rule 13 (expression -> IDENTIFIER .)
    COMPARISONOP    reduce using rule 13 (expression -> IDENTIFIER .)
    )               reduce using rule 13 (expression -> IDENTIFIER .)
    {               reduce using rule 13 (expression -> IDENTIFIER .)


state 19

    (16) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 33
    boolean                        shift and go to state 17

state 20

    (14) boolean -> TRUE .

    ADD_OP          reduce using rule 14 (boolean -> TRUE .)
    MUL_OP          reduce using rule 14 (boolean -> TRUE .)
    ;               reduce using rule 14 (boolean -> TRUE .)
    $end            reduce using rule 14 (boolean -> TRUE .)
    }               reduce using rule 14 (boolean -> TRUE .)
    COMPARISONOP    reduce using rule 14 (boolean -> TRUE .)
    )               reduce using rule 14 (boolean -> TRUE .)
    {               reduce using rule 14 (boolean -> TRUE .)


state 21

    (15) boolean -> FALSE .

    ADD_OP          reduce using rule 15 (boolean -> FALSE .)
    MUL_OP          reduce using rule 15 (boolean -> FALSE .)
    ;               reduce using rule 15 (boolean -> FALSE .)
    $end            reduce using rule 15 (boolean -> FALSE .)
    }               reduce using rule 15 (boolean -> FALSE .)
    COMPARISONOP    reduce using rule 15 (boolean -> FALSE .)
    )               reduce using rule 15 (boolean -> FALSE .)
    {               reduce using rule 15 (boolean -> FALSE .)


state 22

    (19) assignation -> IDENTIFIER = . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 34
    boolean                        shift and go to state 17

state 23

    (18) declaration -> TYPE IDENTIFIER .

    ;               reduce using rule 18 (declaration -> TYPE IDENTIFIER .)
    $end            reduce using rule 18 (declaration -> TYPE IDENTIFIER .)
    }               reduce using rule 18 (declaration -> TYPE IDENTIFIER .)


state 24

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition . { programme }

    {               shift and go to state 35


state 25

    (20) condition -> ( . expression COMPARISONOP expression )
    (16) expression -> ( . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 36
    boolean                        shift and go to state 17

state 26

    (21) condition -> expression . COMPARISONOP expression
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    COMPARISONOP    shift and go to state 37
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 27

    (22) structure -> SERIEUX condition . { programme }
    (23) structure -> SERIEUX condition . { programme } ELSE { programme }

    {               shift and go to state 38


state 28

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( . assignation ; condition ; assignation ) { programme }
    (19) assignation -> . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 7

    assignation                    shift and go to state 39

state 29

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 30

    (8) expression -> expression ADD_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 40
    boolean                        shift and go to state 17

state 31

    (9) expression -> expression MUL_OP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 41
    boolean                        shift and go to state 17

state 32

    (17) expression -> ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    ;               reduce using rule 17 (expression -> ADD_OP expression .)
    $end            reduce using rule 17 (expression -> ADD_OP expression .)
    }               reduce using rule 17 (expression -> ADD_OP expression .)
    COMPARISONOP    reduce using rule 17 (expression -> ADD_OP expression .)
    )               reduce using rule 17 (expression -> ADD_OP expression .)
    {               reduce using rule 17 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 30 ]
  ! MUL_OP          [ shift and go to state 31 ]


state 33

    (16) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 42
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 34

    (19) assignation -> IDENTIFIER = expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ;               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    )               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 35

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (22) structure -> . SERIEUX condition { programme }
    (23) structure -> . SERIEUX condition { programme } ELSE { programme }
    (24) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 43
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 36

    (20) condition -> ( expression . COMPARISONOP expression )
    (16) expression -> ( expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    COMPARISONOP    shift and go to state 44
    )               shift and go to state 42
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 37

    (21) condition -> expression COMPARISONOP . expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 45
    boolean                        shift and go to state 17

state 38

    (22) structure -> SERIEUX condition { . programme }
    (23) structure -> SERIEUX condition { . programme } ELSE { programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (22) structure -> . SERIEUX condition { programme }
    (23) structure -> . SERIEUX condition { programme } ELSE { programme }
    (24) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 46
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 39

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation . ; condition ; assignation ) { programme }

    ;               shift and go to state 47


state 40

    (8) expression -> expression ADD_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 8 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 8 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 8 (expression -> expression ADD_OP expression .)
    }               reduce using rule 8 (expression -> expression ADD_OP expression .)
    COMPARISONOP    reduce using rule 8 (expression -> expression ADD_OP expression .)
    )               reduce using rule 8 (expression -> expression ADD_OP expression .)
    {               reduce using rule 8 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 31

  ! MUL_OP          [ reduce using rule 8 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 30 ]


state 41

    (9) expression -> expression MUL_OP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 9 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 9 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 9 (expression -> expression MUL_OP expression .)
    }               reduce using rule 9 (expression -> expression MUL_OP expression .)
    COMPARISONOP    reduce using rule 9 (expression -> expression MUL_OP expression .)
    )               reduce using rule 9 (expression -> expression MUL_OP expression .)
    {               reduce using rule 9 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 30 ]
  ! MUL_OP          [ shift and go to state 31 ]


state 42

    (16) expression -> ( expression ) .

    ADD_OP          reduce using rule 16 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 16 (expression -> ( expression ) .)
    ;               reduce using rule 16 (expression -> ( expression ) .)
    $end            reduce using rule 16 (expression -> ( expression ) .)
    }               reduce using rule 16 (expression -> ( expression ) .)
    COMPARISONOP    reduce using rule 16 (expression -> ( expression ) .)
    )               reduce using rule 16 (expression -> ( expression ) .)
    {               reduce using rule 16 (expression -> ( expression ) .)


state 43

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme . }

    }               shift and go to state 48


state 44

    (20) condition -> ( expression COMPARISONOP . expression )
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    (               shift and go to state 19
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 49
    boolean                        shift and go to state 17

state 45

    (21) condition -> expression COMPARISONOP expression .
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    {               reduce using rule 21 (condition -> expression COMPARISONOP expression .)
    ;               reduce using rule 21 (condition -> expression COMPARISONOP expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 46

    (22) structure -> SERIEUX condition { programme . }
    (23) structure -> SERIEUX condition { programme . } ELSE { programme }

    }               shift and go to state 50


state 47

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; . condition ; assignation ) { programme }
    (20) condition -> . ( expression COMPARISONOP expression )
    (21) condition -> . expression COMPARISONOP expression
    (8) expression -> . expression ADD_OP expression
    (9) expression -> . expression MUL_OP expression
    (10) expression -> . NUMBER
    (11) expression -> . INT
    (12) expression -> . boolean
    (13) expression -> . IDENTIFIER
    (16) expression -> . ( expression )
    (17) expression -> . ADD_OP expression
    (14) boolean -> . TRUE
    (15) boolean -> . FALSE

    (               shift and go to state 25
    NUMBER          shift and go to state 15
    INT             shift and go to state 16
    IDENTIFIER      shift and go to state 18
    ADD_OP          shift and go to state 14
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    condition                      shift and go to state 51
    expression                     shift and go to state 26
    boolean                        shift and go to state 17

state 48

    (7) structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .

    ;               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)
    $end            reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)
    }               reduce using rule 7 (structure -> ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme } .)


state 49

    (20) condition -> ( expression COMPARISONOP expression . )
    (8) expression -> expression . ADD_OP expression
    (9) expression -> expression . MUL_OP expression

    )               shift and go to state 52
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31


state 50

    (22) structure -> SERIEUX condition { programme } .
    (23) structure -> SERIEUX condition { programme } . ELSE { programme }

    ;               reduce using rule 22 (structure -> SERIEUX condition { programme } .)
    $end            reduce using rule 22 (structure -> SERIEUX condition { programme } .)
    }               reduce using rule 22 (structure -> SERIEUX condition { programme } .)
    ELSE            shift and go to state 53


state 51

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition . ; assignation ) { programme }

    ;               shift and go to state 54


state 52

    (20) condition -> ( expression COMPARISONOP expression ) .

    {               reduce using rule 20 (condition -> ( expression COMPARISONOP expression ) .)
    ;               reduce using rule 20 (condition -> ( expression COMPARISONOP expression ) .)


state 53

    (23) structure -> SERIEUX condition { programme } ELSE . { programme }

    {               shift and go to state 55


state 54

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; . assignation ) { programme }
    (19) assignation -> . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 7

    assignation                    shift and go to state 56

state 55

    (23) structure -> SERIEUX condition { programme } ELSE { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (22) structure -> . SERIEUX condition { programme }
    (23) structure -> . SERIEUX condition { programme } ELSE { programme }
    (24) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    programme                      shift and go to state 57
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 56

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation . ) { programme }

    )               shift and go to state 58


state 57

    (23) structure -> SERIEUX condition { programme } ELSE { programme . }

    }               shift and go to state 59


state 58

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) . { programme }

    {               shift and go to state 60


state 59

    (23) structure -> SERIEUX condition { programme } ELSE { programme } .

    ;               reduce using rule 23 (structure -> SERIEUX condition { programme } ELSE { programme } .)
    $end            reduce using rule 23 (structure -> SERIEUX condition { programme } ELSE { programme } .)
    }               reduce using rule 23 (structure -> SERIEUX condition { programme } ELSE { programme } .)


state 60

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . declaration
    (5) statement -> . structure
    (6) statement -> . PAS_MAL expression
    (19) assignation -> . IDENTIFIER = expression
    (18) declaration -> . TYPE IDENTIFIER
    (7) structure -> . ON_SE_LE_REFAIT_UNE_PETITE_FOIS condition { programme }
    (22) structure -> . SERIEUX condition { programme }
    (23) structure -> . SERIEUX condition { programme } ELSE { programme }
    (24) structure -> . C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme }

    PAS_MAL         shift and go to state 6
    IDENTIFIER      shift and go to state 7
    TYPE            shift and go to state 8
    ON_SE_LE_REFAIT_UNE_PETITE_FOIS shift and go to state 9
    SERIEUX         shift and go to state 10
    C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON shift and go to state 11

    assignation                    shift and go to state 3
    programme                      shift and go to state 61
    statement                      shift and go to state 2
    declaration                    shift and go to state 4
    structure                      shift and go to state 5

state 61

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme . }

    }               shift and go to state 62


state 62

    (24) structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .

    ;               reduce using rule 24 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)
    $end            reduce using rule 24 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)
    }               reduce using rule 24 (structure -> C_EST_EN_FORGEANT_QU_ON_DEVIENT_FORGERON ( assignation ; condition ; assignation ) { programme } .)

